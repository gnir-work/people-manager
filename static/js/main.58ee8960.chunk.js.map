{"version":3,"sources":["types/person.ts","consts.ts","api/people.tsx","contexts/PeopleContext.tsx","components/filters/TableTextFilter.tsx","utils/sorters.ts","utils/filters.ts","components/tags/EditableTag.tsx","components/PeopleTable/PersonTag.tsx","components/actions/DeleteButton.tsx","components/PeopleTable/EditableText.tsx","components/tags/AddTag.tsx","components/tags/TagList.tsx","components/PeopleTable/PersonTags.tsx","components/fields/BooleanField.tsx","components/validators/validators.ts","components/validators/consts.ts","components/PeopleTable/PeopleTableColumns.tsx","components/PeopleTable/PeopleTable.tsx","components/actions/AddButton.tsx","components/PeopleTable/AddPersonModal.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Person","args","id","fullName","personalId","phone","status","team","remarks","preferences","megamut","subjects","availability","wasSegel","this","PERSON_STATUSES","PERSON_PREFERENCES","MEGAMUT","SUBJECTS","AVAILABILITY","STATUS_TO_COLOR","אזרח","חייל","PREFERENCE_TO_COLOR","הרצאות","MEGAMUT_TO_COLOR","מערכות","מקורות","מחקר","AVAILABILITY_TO_COLOR","זמין","ANTD_BOOLEAN_FILTERS","text","value","getRandomNumberOfItemsFromList","data","slice","_","random","length","PeopleContext","createContext","people","deletePerson","personToDelete","getFieldDataSet","field","updatePerson","newPerson","addPerson","newPersonFields","doesPersonExist","personId","PeopleContextProvider","children","useState","setPeople","useEffect","range","map","sample","toString","find","Provider","filteredPeople","filter","person","fields","uniq","newPeople","TableTextFilter","setSelectedKeys","selectedKeys","confirm","clearFilters","className","ref","instance","focus","placeholder","onChange","e","newKeys","target","onPressEnter","type","onClick","icon","SearchOutlined","size","sortByField","firstPerson","secondPerson","stringsFilterByField","toLowerCase","includes","arrayFilterByField","arrayToAntdMappings","filters","EditableTag","possibleTags","color","onTagChange","onDelete","undefined","editing","setEditing","searchText","setSearchText","filteredTags","possibleTag","toggleEditing","tagProps","onClose","autoFocus","options","tag","onSelect","defaultOpen","onBlur","classNames","clickable","closable","PersonTag","colors","useContext","newTag","message","success","PeopleTableDeleteButton","title","onConfirm","error","okText","cancelText","placement","DeleteFilled","EditableText","initialValue","rules","useForm","form","name","Item","defaultValue","onDoubleClick","validateFields","then","values","AddTag","onSubmit","setFilter","newFilter","PlusOutlined","TagList","tags","additionText","unselectedTags","isEmpty","key","currentTag","tagToDelete","oldTag","FilteredTags","handleTagChange","PersonTags","newTags","BooleanField","checked","GET_PERSONAL_ID_RULES","required","validator","rule","Promise","reject","resolve","transform","toNumber","GET_BASIC_TEXT_RULES","character","onlyHebrewCharacters","GET_PHONE_NUMBER_RULES","min","PeopleTableColumns","dataIndex","sorter","onFilter","record","filterDropdown","render","width","currentAvailability","preference","megama","subject","String","PeopleTable","peopleContext","dataSource","columns","pagination","pageSize","AddButton","buttonRef","useRef","current","blur","layout","labelCol","span","wrapperCol","initialValues","AddPersonModal","visible","setVisible","Form","hideModal","submitModal","resetFields","catch","onOk","onCancel","onKeyDown","event","label","Group","valuePropName","Header","Layout","Content","Footer","App","theme","mode","style","lineHeight","Boolean","window","location","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.58ee8960.chunk.js","sourcesContent":["export interface PersonFields {\n  fullName: string;\n  personalId: string;\n  phone: string;\n  status: string;\n  team: string;\n  megamut: string[];\n  subjects: string[];\n  availability: string;\n  wasSegel?: boolean;\n  remarks?: string;\n  preferences?: string[];\n}\n\nexport class Person {\n  readonly id: string;\n  fullName: string;\n  personalId: string;\n  phone: string;\n  status: string;\n  team: string;\n  remarks: string;\n  preferences: string[];\n  megamut: string[];\n  subjects: string[];\n  availability: string;\n  wasSegel: boolean;\n\n  constructor(args: PersonFields) {\n    this.id = args.personalId;\n    this.fullName = args.fullName;\n    this.personalId = args.personalId;\n    this.phone = args.phone;\n    this.status = args.status;\n    this.team = args.team;\n    this.remarks = args.remarks || \"\";\n    this.preferences = args.preferences || [];\n    this.megamut = args.megamut || [];\n    this.subjects = args.subjects || [];\n    this.availability = args.availability || \"\";\n    this.wasSegel = args.wasSegel || false;\n  }\n}\n","export const PERSON_STATUSES = [\"אזרח\", \"חייל\"];\n\nexport const PERSON_PREFERENCES = [\"בדיקת תרגילים\", \"הרצאות\", \"להישאר לישון\"];\n\nexport const MEGAMUT = [\"מערכות\", \"מחקר\", \"מקורות\"];\n\nexport const SUBJECTS = [\"python\", \"C\", \"ביטים\"];\n\nexport const AVAILABILITY = [\"לא זמין\", \"זמין אבל עמוס\", \"זמין\"];\n\nexport const STATUS_TO_COLOR: {\n  [key: string]: string;\n} = {\n  אזרח: \"blue\",\n  חייל: \"green\"\n};\n\nexport const PREFERENCE_TO_COLOR: {\n  [key: string]: string;\n} = {\n  \"בדיקת תרגילים\": \"magenta\",\n  הרצאות: \"geekblue\",\n  \"להישאר לישון\": \"volcano\"\n};\n\nexport const MEGAMUT_TO_COLOR: {\n  [key: string]: string;\n} = {\n  מערכות: \"green\",\n  מקורות: \"orange\",\n  מחקר: \"purple\"\n};\n\nexport const AVAILABILITY_TO_COLOR = {\n  \"לא זמין\": \"red\",\n  \"זמין אבל עמוס\": \"orange\",\n  זמין: \"green\"\n};\n\n/**\n * Filters for the antd table component that correspond to boolean fields.\n */\nexport const ANTD_BOOLEAN_FILTERS = [\n  {\n    text: \"כן\",\n    value: \"true\"\n  },\n  {\n    text: \"לא\",\n    value: \"false\"\n  }\n];\n\nexport const EDIT_SUCCESS_MESSAGE = \"שדה עודכן בהצלחה.\";\n","import _ from \"lodash\";\n\nimport { Person } from \"../types/person\";\nimport {\n  PERSON_PREFERENCES,\n  PERSON_STATUSES,\n  MEGAMUT,\n  SUBJECTS,\n  AVAILABILITY\n} from \"../consts\";\n\nconst getRandomNumberOfItemsFromList = (data: any[]) =>\n  data.slice(0, _.random(0, data.length));\n\nexport const getPeople = (): Person[] =>\n  _.range(1000).map(\n    id =>\n      new Person({\n        team: \"פיירו\",\n        status: _.sample(PERSON_STATUSES) || PERSON_STATUSES[0],\n        phone: \"053-0000000\",\n        personalId: _.random(10000000, 99999999).toString(),\n        fullName: \"ניר גלר\" + _.random(1, 100).toString(),\n        remarks: \"ששדגדשג\",\n        preferences: getRandomNumberOfItemsFromList(PERSON_PREFERENCES),\n        megamut: getRandomNumberOfItemsFromList(MEGAMUT),\n        subjects: getRandomNumberOfItemsFromList(SUBJECTS),\n        availability: _.sample(AVAILABILITY) || AVAILABILITY[0],\n        wasSegel: _.sample([true, false])\n      })\n  );\n","import React, { createContext, useEffect, useState } from \"react\";\nimport { getPeople } from \"../api/people\";\nimport { Person, PersonFields } from \"../types/person\";\nimport _ from \"lodash\";\n\nexport interface PeopleContextInterface {\n  people: Person[];\n  deletePerson: (personToDelete: Person) => boolean;\n  getFieldDataSet: (field: keyof Person) => any[];\n  updatePerson: (newPerson: Person) => void;\n  addPerson: (newPersonFields: PersonFields) => void;\n  doesPersonExist: (personId: string) => boolean;\n}\n\nconst defaultData: PeopleContextInterface = {\n  people: [],\n  deletePerson: (personToDelete: Person) => true,\n  getFieldDataSet: (field: keyof Person) => [],\n  updatePerson: (newPerson: Person) => {},\n  addPerson: (newPersonFields: PersonFields) => {},\n  doesPersonExist: (personId: string) => false\n};\n\nexport const PeopleContext = createContext(defaultData);\n\n/**\n * A context which handles all of the manipulation on the people dataset.\n * From fetching the data set to deleting or adding people.\n */\nexport const PeopleContextProvider: React.FC = ({ children }) => {\n  const [people, setPeople]: [Person[], Function] = useState([]);\n\n  useEffect(() => {\n    setPeople(getPeople());\n  }, []);\n\n  /**\n   * Check if we already have a person with this id.\n   * @param personId The id of the person.\n   */\n  const doesPersonExist = (personId: string) =>\n    !!_.find(people, [\"id\", personId]);\n\n  /**\n   * Deletes a specific person identified by id.\n   *\n   * @param personToDelete The person to delete from the dataset.\n   * @returns a boolean indicating the success of the operation.\n   */\n  const deletePerson = (personToDelete: Person): boolean => {\n    if (doesPersonExist(personToDelete.id)) {\n      const filteredPeople = people.filter(\n        person => person.id !== personToDelete.id\n      );\n      setPeople(filteredPeople);\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  /**\n   * Retrieves all of the unique values of a given field.\n   * @param field The field from which the data set should be built\n   */\n  const getFieldDataSet = (field: keyof Person) => {\n    const fields = people.map((person: Person) => person[field]);\n    return _.uniq(fields);\n  };\n\n  /**\n   * Update a specific person.\n   */\n  const updatePerson = (newPerson: Person) => {\n    const newPeople = [\n      ...people.map(person => (person.id === newPerson.id ? newPerson : person))\n    ];\n    setPeople(newPeople);\n  };\n\n  /**\n   * Create new Person\n   */\n  const addPerson = (newPersonFields: PersonFields) => {\n    setPeople([...people, new Person(newPersonFields)]);\n  };\n\n  return (\n    <PeopleContext.Provider\n      value={{\n        doesPersonExist,\n        addPerson,\n        people,\n        deletePerson,\n        getFieldDataSet,\n        updatePerson\n      }}\n    >\n      {children}\n    </PeopleContext.Provider>\n  );\n};\n","import React from \"react\";\nimport { Input, Button } from \"antd\";\nimport { SearchOutlined } from \"@ant-design/icons\";\n\nimport \"./TableTextFilter.scss\";\n\ninterface TableTextFilterProps {\n  setSelectedKeys: (newFilters: string[]) => void;\n  selectedKeys: string[];\n  confirm: () => void;\n  clearFilters: () => void;\n}\n\nconst TableTextFilter: React.FC<TableTextFilterProps> = ({\n  setSelectedKeys,\n  selectedKeys,\n  confirm,\n  clearFilters\n}) => {\n  const onSearch = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const newKeys = e.target.value ? [e.target.value] : [];\n    setSelectedKeys(newKeys);\n  };\n\n  return (\n    <div className=\"table-filter\">\n      <Input\n        ref={(instance: Input) => {\n          if (instance) {\n            instance.focus();\n          }\n        }}\n        placeholder={`הכנס את החיפוש`}\n        value={selectedKeys[0]}\n        onChange={onSearch}\n        className=\"search-input\"\n        onPressEnter={confirm}\n      />\n      <Button\n        type=\"primary\"\n        onClick={confirm}\n        icon={<SearchOutlined />}\n        size=\"small\"\n        className=\"search-button\"\n      >\n        חפש\n      </Button>\n      <Button onClick={clearFilters} size=\"small\" className=\"clear-button\">\n        נקה חיפוש\n      </Button>\n    </div>\n  );\n};\n\nexport default TableTextFilter;\n","import { Person } from \"../types/person\";\n\n/**\n * Compares between two person objects by a specific field.\n * @param firstPerson\n * @param secondPerson\n * @param field The field name by which the objects should be compared\n */\nexport const sortByField = (\n  firstPerson: Person,\n  secondPerson: Person,\n  field: keyof Person\n): number => {\n  if (firstPerson[field] > secondPerson[field]) {\n    return 1;\n  } else if (firstPerson[field] < secondPerson[field]) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\n","import { Person } from \"../types/person\";\nimport { ConditionalProps, getElementType } from \"./types\";\nimport moment, { Moment } from \"moment\";\n\n/**\n * Checks if the person value of the property key contains the given value.\n * Please notice: the check ignores case.\n * @param person The person that should be filtered.\n * @param text The value that should be part of the fields value.\n * @param field The field to check against\n */\nexport const stringsFilterByField = (\n  person: Person,\n  text: string,\n  field: ConditionalProps<Person, string>\n) => person[field].toLowerCase().includes(text.toLowerCase());\n\n/**\n * Checks wether the persons date field is within the range given.\n * Please notice the range is inclusive on both ends (since and until).\n * @param person The person that should be filtered.\n * @param datesRange The dates range by which we will filter\n * @param field The date field that will be filtered.\n */\nexport const datesFilterByField = (\n  person: Person,\n  datesRange: { since: Moment; until: Moment },\n  field: ConditionalProps<Person, moment.Moment>\n) =>\n  datesRange.since.startOf(\"day\") <= person[field] &&\n  person[field] <= datesRange.until.endOf(\"day\");\n\nexport function arrayFilterByField<\n  K extends ConditionalProps<Person, Array<any>>\n>(person: Person, value: getElementType<Person[K]>, field: K) {\n  return (person[field] as any).includes(value);\n}\n\n/**\n * Convert an array of literals to antd filters format.\n * @param filters\n */\nexport const arrayToAntdMappings = (filters: string[]) =>\n  filters.map((value: string) => ({\n    text: value,\n    value\n  }));\n","import React, { useState } from \"react\";\nimport { AutoComplete, Tag } from \"antd\";\nimport { SelectValue } from \"antd/lib/select\";\nimport { TagProps } from \"antd/lib/tag\";\nimport classNames from \"classnames\";\n\ninterface EditableTagProps extends TagProps {\n  possibleTags: string[];\n  color?: string;\n  onTagChange: (newTag: string) => void;\n  onDelete?: () => void;\n}\n\n/**\n * An editable tag with multiple functionalities.\n * In case the tag can be deleted entirely and not only changed please pass a function\n * to handle that case to the onDelete prop.\n *\n * Please notice:\n * In case the tag can be deleted, clicking the tag will prompt the user to change\n * its value while clicking the close icon will delete the tag.\n *\n * In case the tag can't be deleted only clicking the close icon will prompt the user\n * to change the tags value.\n */\nconst EditableTag: React.FC<EditableTagProps> = ({\n  possibleTags,\n  color = \"\",\n  onTagChange,\n  children,\n  onDelete = undefined\n}) => {\n  const [editing, setEditing] = useState(false);\n  const [searchText, setSearchText] = useState(\"\");\n  const filteredTags = possibleTags.filter(possibleTag =>\n    possibleTag.includes(searchText)\n  );\n\n  const toggleEditing = () => {\n    setEditing(!editing);\n    setSearchText(\"\");\n  };\n\n  const handleSelection = (value: SelectValue) => {\n    onTagChange(value.toString());\n    toggleEditing();\n  };\n\n  const handleChange = (value: SelectValue) => {\n    setSearchText(value.toString());\n  };\n\n  const tagProps = onDelete\n    ? {\n        onClose: onDelete,\n        onClick: toggleEditing\n      }\n    : {\n        onClose: toggleEditing\n      };\n\n  return editing ? (\n    <AutoComplete\n      autoFocus\n      onChange={handleChange}\n      options={filteredTags.map(tag => ({ value: tag }))}\n      onSelect={handleSelection}\n      defaultOpen\n      onBlur={toggleEditing}\n      value={searchText}\n    />\n  ) : (\n    <Tag\n      className={classNames({ clickable: onDelete })}\n      color={color}\n      closable\n      {...tagProps}\n    >\n      {children}\n    </Tag>\n  );\n};\n\nexport default EditableTag;\n","import React, { useContext } from \"react\";\nimport EditableTag from \"../tags/EditableTag\";\nimport { PeopleContext } from \"../../contexts/PeopleContext\";\nimport { Person } from \"../../types/person\";\nimport { ConditionalProps } from \"../../utils/types\";\nimport { message } from \"antd\";\nimport { EDIT_SUCCESS_MESSAGE } from \"../../consts\";\n\nexport interface PersonTag {\n  person: Person;\n  field: ConditionalProps<Person, string>;\n  colors?: {\n    [color: string]: string;\n  };\n  possibleTags: string[];\n}\n\nconst PersonTag: React.FC<PersonTag> = ({\n  person,\n  field,\n  colors = {},\n  possibleTags\n}) => {\n  const { updatePerson } = useContext(PeopleContext);\n\n  const handleTagChange = (newTag: string) => {\n    const newPerson = {\n      ...person,\n      [field]: newTag\n    };\n    updatePerson(newPerson);\n    message.success(EDIT_SUCCESS_MESSAGE);\n  };\n\n  return (\n    <EditableTag\n      onTagChange={handleTagChange}\n      possibleTags={possibleTags}\n      color={colors[person[field]]}\n    >\n      {person[field]}\n    </EditableTag>\n  );\n};\n\nexport default PersonTag;\n","import React, { useContext } from \"react\";\nimport { message, Popconfirm } from \"antd\";\nimport { DeleteFilled } from \"@ant-design/icons\";\nimport { PeopleContext } from \"../../contexts/PeopleContext\";\nimport { Person } from \"../../types/person\";\n\nimport \"./DeleteButton.scss\";\n\ninterface PeopleTableDeleteButtonProps {\n  person: Person;\n}\n\n/**\n * A delete button specific for the peoples data table.\n */\nconst PeopleTableDeleteButton: React.FC<PeopleTableDeleteButtonProps> = ({\n  person\n}) => {\n  const { deletePerson } = useContext(PeopleContext);\n\n  const handlePersonDeletion = () => {\n    if (deletePerson(person)) {\n      message.success(`${person.fullName} נמחק בהצלחה!`);\n    } else {\n      message.error(`לא ניתן למחוק את ${person.fullName}`);\n    }\n  };\n\n  return (\n    <Popconfirm\n      title={`האם למחוק את ${person.fullName}?`}\n      onConfirm={handlePersonDeletion}\n      okText=\"כן\"\n      cancelText=\"לא\"\n      placement=\"right\"\n    >\n      <DeleteFilled />\n    </Popconfirm>\n  );\n};\n\nexport default PeopleTableDeleteButton;\n","import React, { useContext, useState } from \"react\";\nimport { message, Input, Form } from \"antd\";\nimport { Person } from \"../../types/person\";\nimport { PeopleContext } from \"../../contexts/PeopleContext\";\nimport { ConditionalProps } from \"../../utils/types\";\n\nimport \"./EditableText.scss\";\nimport { EDIT_SUCCESS_MESSAGE } from \"../../consts\";\nimport { useForm } from \"antd/lib/form/util\";\nimport { Rule } from \"antd/lib/form\";\n\ninterface PeopleTableEditableTextProps {\n  initialValue: string;\n  field: ConditionalProps<Person, string>;\n  person: Person;\n  rules?: Rule[];\n}\n\nconst EditableText: React.FC<PeopleTableEditableTextProps> = ({\n  field,\n  person,\n  initialValue,\n  rules = []\n}) => {\n  const [editing, setEditing] = useState(false);\n  const { updatePerson } = useContext(PeopleContext);\n  const [form] = useForm();\n\n  const toggleEditing = () => {\n    setEditing(!editing);\n  };\n\n  const handleTextChange = () => {\n    form.validateFields().then(values => {\n      updatePerson({ ...person, [field]: values.text });\n      setEditing(false);\n      message.success(EDIT_SUCCESS_MESSAGE);\n    });\n  };\n\n  return editing ? (\n    <Form name=\"editable_text_form\" form={form}>\n      <Form.Item name=\"text\" rules={rules}>\n        <Input\n          defaultValue={initialValue}\n          onDoubleClick={toggleEditing}\n          autoFocus\n          onBlur={toggleEditing}\n          onPressEnter={handleTextChange}\n        />\n      </Form.Item>\n    </Form>\n  ) : (\n    <span className=\"editable-field clickable\" onClick={toggleEditing}>\n      {initialValue}\n    </span>\n  );\n};\n\nexport default EditableText;\n","import React, { useState, useEffect } from \"react\";\nimport { AutoComplete, Tag } from \"antd\";\nimport { PlusOutlined } from \"@ant-design/icons\";\nimport { SelectValue } from \"antd/lib/select\";\n\nimport \"./AddTag.scss\";\n\ninterface AddTagProps {\n  possibleTags: string[];\n  onSubmit: (newTag: string) => void;\n  text: string;\n}\n\nconst AddTag: React.FC<AddTagProps> = ({ possibleTags, onSubmit, text }) => {\n  const [editing, setEditing] = useState(false);\n  const [filter, setFilter] = useState(\"\");\n  const filteredTags = possibleTags.filter(tag => tag.includes(filter));\n\n  /**\n   * We want a fresh filter each time we enter or exit the filtering state.\n   */\n  useEffect(() => {\n    setFilter(\"\");\n  }, [editing]);\n\n  /**\n   * Handle the selection of a value from the auto complete.\n   * @param value\n   */\n  const handleSelection = (value: SelectValue) => {\n    setEditing(false);\n    onSubmit(value.toString());\n  };\n\n  const toggleEditing = () => {\n    setEditing(!editing);\n  };\n\n  const handleChange = (newFilter: SelectValue) => {\n    setFilter(newFilter.toString());\n  };\n\n  return editing ? (\n    <AutoComplete\n      onChange={handleChange}\n      autoFocus\n      defaultOpen\n      options={filteredTags.map(tag => ({ value: tag }))}\n      onSelect={handleSelection}\n      onBlur={toggleEditing}\n    />\n  ) : (\n    <Tag onClick={toggleEditing} className=\"clickable add-tag\">\n      <PlusOutlined /> {text}\n    </Tag>\n  );\n};\n\nexport default AddTag;\n","import React from \"react\";\nimport AddTag from \"./AddTag\";\n\nimport \"./TagList.scss\";\nimport _ from \"lodash\";\nimport EditableTag from \"./EditableTag\";\n\ninterface TagListProps {\n  tags?: string[];\n  possibleTags: string[];\n  colors?: {\n    [color: string]: string;\n  };\n  additionText: string;\n  onChange?: (newTags: string[]) => void;\n}\n\nconst TagList: React.FC<TagListProps> = ({\n  tags = [],\n  possibleTags,\n  colors = {},\n  onChange = () => {},\n  additionText\n}) => {\n  let unselectedTags = possibleTags.filter(tag => !tags.includes(tag));\n\n  const handleTagDeletion = (tagToDelete: string) => {\n    onChange(tags.filter(tag => tag !== tagToDelete));\n  };\n\n  const handleTagAddition = (newTag: string) => {\n    onChange([...tags, newTag]);\n  };\n\n  const handleTagChange = (oldTag: string, newTag: string) => {\n    const FilteredTags = tags.filter(tag => tag !== oldTag);\n    onChange([...FilteredTags, newTag]);\n  };\n\n  /**\n   * We want the current value of the tag to be a possible tag that the user\n   * can change the current value to because of the following:\n   * In case there are no other options (All of the possibleTags are selected) when a person\n   * clicks a tag to edit it its weird that there are no options, it looks a lot better\n   * if the current value is available.\n   * @param currentTag The current value of the editable tag.\n   */\n  const getEditableTagPossibleTags = (currentTag: string) => [\n    ...unselectedTags,\n    currentTag\n  ];\n\n  return (\n    <div className=\"tag-list\">\n      {tags.map(tag => (\n        <EditableTag\n          color={_.isEmpty(colors) ? \"\" : colors[tag]}\n          key={tag}\n          possibleTags={getEditableTagPossibleTags(tag)}\n          onDelete={() => handleTagDeletion(tag)}\n          onTagChange={(newTag: string) => handleTagChange(tag, newTag)}\n          closable\n        >\n          {tag}\n        </EditableTag>\n      ))}\n      {unselectedTags.length > 0 && (\n        <AddTag\n          text={additionText}\n          possibleTags={unselectedTags}\n          onSubmit={handleTagAddition}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default TagList;\n","import React, { useContext } from \"react\";\nimport { Person } from \"../../types/person\";\nimport { PeopleContext } from \"../../contexts/PeopleContext\";\nimport TagList from \"../tags/TagList\";\nimport { ConditionalProps } from \"../../utils/types\";\nimport { message } from \"antd\";\nimport { EDIT_SUCCESS_MESSAGE } from \"../../consts\";\n\ninterface PersonPreferenceTagsProps {\n  person: Person;\n  field: ConditionalProps<Person, Array<any>>;\n  possibleTags: string[];\n  colors?: {\n    [color: string]: string;\n  };\n}\n\nconst PersonTags: React.FC<PersonPreferenceTagsProps> = ({\n  person,\n  field,\n  possibleTags,\n  colors = {}\n}) => {\n  const { updatePerson } = useContext(PeopleContext);\n\n  /**\n   * Add the new tag to the current person\n   * @param value\n   */\n  const handleTagsChange = (newTags: string[]) => {\n    const newPerson = {\n      ...person,\n      [field]: newTags\n    };\n    updatePerson(newPerson);\n    message.success(EDIT_SUCCESS_MESSAGE);\n  };\n\n  return (\n    <TagList\n      tags={person[field]}\n      colors={colors}\n      possibleTags={possibleTags}\n      onChange={handleTagsChange}\n      additionText=\"הוספת העדפה\"\n    />\n  );\n};\n\nexport default PersonTags;\n","import React, { useContext } from \"react\";\nimport { Person } from \"../../types/person\";\nimport { ConditionalProps } from \"../../utils/types\";\nimport { PeopleContext } from \"../../contexts/PeopleContext\";\nimport { message, Checkbox } from \"antd\";\nimport { EDIT_SUCCESS_MESSAGE } from \"../../consts\";\n\ninterface BooleanFieldProps {\n  person: Person;\n  field: ConditionalProps<Person, boolean>;\n}\n\nconst BooleanField: React.FC<BooleanFieldProps> = ({ person, field }) => {\n  const { updatePerson } = useContext(PeopleContext);\n\n  const handleClick = () => {\n    const newPerson = {\n      ...person,\n      [field]: !person[field]\n    };\n    updatePerson(newPerson);\n    message.success(EDIT_SUCCESS_MESSAGE);\n  };\n\n  return (\n    <Checkbox\n      checked={person[field]}\n      className=\"clickable\"\n      onClick={handleClick}\n    />\n  );\n};\n\nexport default BooleanField;\n","import { ALLOWED_CHARACTERS, MIN_PHONE_LENGTH } from \"./consts\";\nimport _ from \"lodash\";\nimport { Rule } from \"antd/lib/form\";\n\n/**\n * Checks if value contains only hebrew characters\n * @param value The string to check.\n */\nexport const onlyHebrewCharacters = (value: string): boolean => {\n  for (const character of value) {\n    if (!ALLOWED_CHARACTERS.includes(character)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// From here down you can find antd rules for validating fields.\n\nexport const GET_PERSONAL_ID_RULES = (doesPersonExist: Function): Rule[] => [\n  { required: true, message: \"בבקשה הכנס מספר אישי\" },\n  {\n    validator(rule: any, value: string) {\n      if (!doesPersonExist(value)) {\n        return Promise.resolve();\n      } else {\n        return Promise.reject(\"כבר יש איש חוץ עם המספר אישי הזה\");\n      }\n    }\n  },\n  {\n    message: \"המספר אישי חייב להכיל רק מספרים\",\n    transform: (value: string) => _.toNumber(value),\n    type: \"number\"\n  }\n];\n\nexport const GET_BASIC_TEXT_RULES = (): Rule[] => [\n  { required: true, message: \"בבקשה הכנס שם מלא\" },\n  {\n    validator(rule, value) {\n      if (onlyHebrewCharacters(value)) {\n        return Promise.resolve();\n      } else {\n        return Promise.reject(\"השם חייב להכין רק תווים בעברית או רווח\");\n      }\n    }\n  }\n];\n\nexport const GET_PHONE_NUMBER_RULES = (): Rule[] => [\n  {\n    required: true,\n    message: \"בבקשה הכנס מספר פלאפון\"\n  },\n  {\n    message: \"המספר פלאפון חייב להכיל רק מספרים\",\n    transform: value => _.toNumber(value),\n    type: \"number\"\n  },\n  {\n    message: `המספר פלאפון חייב להכין לפחות ${MIN_PHONE_LENGTH} תוים`,\n    min: MIN_PHONE_LENGTH\n  }\n];\n","export const MIN_PHONE_LENGTH = 7;\n\nexport const ALLOWED_CHARACTERS = \"אבגדהוזחטיכךלמםנןסעפףצץקרשת \";\n","import React from \"react\";\n\nimport TableTextFilter from \"../filters/TableTextFilter\";\nimport { sortByField } from \"../../utils/sorters\";\nimport {\n  stringsFilterByField,\n  arrayToAntdMappings,\n  arrayFilterByField\n} from \"../../utils/filters\";\nimport { Person } from \"../../types/person\";\nimport PersonTag from \"./PersonTag\";\nimport PeopleTableDeleteButton from \"../actions/DeleteButton\";\nimport EditableText from \"./EditableText\";\nimport PersonTags from \"./PersonTags\";\nimport {\n  PERSON_STATUSES,\n  PERSON_PREFERENCES,\n  MEGAMUT,\n  PREFERENCE_TO_COLOR,\n  MEGAMUT_TO_COLOR,\n  SUBJECTS,\n  STATUS_TO_COLOR,\n  AVAILABILITY_TO_COLOR,\n  AVAILABILITY,\n  ANTD_BOOLEAN_FILTERS\n} from \"../../consts\";\nimport BooleanField from \"../fields/BooleanField\";\nimport {\n  GET_PERSONAL_ID_RULES,\n  GET_BASIC_TEXT_RULES,\n  GET_PHONE_NUMBER_RULES\n} from \"../validators/validators\";\nimport { PeopleContextInterface } from \"../../contexts/PeopleContext\";\n\nexport const PeopleTableColumns = ({\n  doesPersonExist\n}: PeopleContextInterface) => [\n  {\n    title: \"שם מלא\",\n    dataIndex: \"fullName\",\n    key: \"fullName\",\n    sorter: (firstPerson: Person, secondPerson: Person) =>\n      sortByField(firstPerson, secondPerson, \"fullName\"),\n    onFilter: (value: string, record: Person) =>\n      stringsFilterByField(record, value, \"fullName\"),\n    filterDropdown: TableTextFilter,\n    render: (value: string, record: Person) => (\n      <EditableText\n        field=\"fullName\"\n        person={record}\n        initialValue={value}\n        rules={GET_BASIC_TEXT_RULES()}\n      />\n    ),\n    width: \"15em\"\n  },\n  {\n    title: \"מ.א\",\n    dataIndex: \"personalId\",\n    key: \"personalId\",\n    sorter: (firstPerson: Person, secondPerson: Person) =>\n      sortByField(firstPerson, secondPerson, \"personalId\"),\n    onFilter: (value: string, record: Person) =>\n      stringsFilterByField(record, value, \"personalId\"),\n    filterDropdown: TableTextFilter,\n    render: (value: string, record: Person) => (\n      <EditableText\n        field=\"personalId\"\n        person={record}\n        initialValue={value}\n        rules={GET_PERSONAL_ID_RULES(doesPersonExist)}\n      />\n    ),\n    width: \"15em\"\n  },\n  {\n    title: \"פלאפון\",\n    dataIndex: \"phone\",\n    key: \"phone\",\n    render: (value: string, record: Person) => (\n      <EditableText\n        field=\"phone\"\n        person={record}\n        initialValue={value}\n        rules={GET_PHONE_NUMBER_RULES()}\n      />\n    ),\n    width: \"12em\"\n  },\n  {\n    title: \"מצב שירות\",\n    dataIndex: \"status\",\n    sorter: (firstPerson: Person, secondPerson: Person) =>\n      sortByField(firstPerson, secondPerson, \"status\"),\n    key: \"status\",\n    render: (status: string, record: Person) => (\n      <PersonTag\n        field=\"status\"\n        possibleTags={PERSON_STATUSES}\n        colors={STATUS_TO_COLOR}\n        person={record}\n      />\n    ),\n    filters: arrayToAntdMappings(PERSON_STATUSES),\n    onFilter: (status: string, record: Person) => record.status === status\n  },\n  {\n    title: \"זמינות\",\n    dataIndex: \"availability\",\n    key: \"availability\",\n    sorter: (firstPerson: Person, secondPerson: Person) =>\n      sortByField(firstPerson, secondPerson, \"availability\"),\n    render: (currentAvailability: string, record: Person) => (\n      <PersonTag\n        field=\"availability\"\n        possibleTags={AVAILABILITY}\n        colors={AVAILABILITY_TO_COLOR}\n        person={record}\n      />\n    ),\n    filters: arrayToAntdMappings(AVAILABILITY),\n    onFilter: (availability: string, record: Person) =>\n      record.availability === availability\n  },\n  {\n    title: \"צוות\",\n    dataIndex: \"team\",\n    key: \"team\",\n    sorter: (firstPerson: Person, secondPerson: Person) =>\n      sortByField(firstPerson, secondPerson, \"team\"),\n    onFilter: (value: string, record: Person) =>\n      stringsFilterByField(record, value, \"team\"),\n    filterDropdown: TableTextFilter,\n    render: (value: string, record: Person) => (\n      <EditableText field=\"team\" person={record} initialValue={value} />\n    ),\n    width: \"12em\"\n  },\n  {\n    title: \"העדפות\",\n    dataIndex: \"preferences\",\n    key: \"preferences\",\n    render: (data: string[], record: Person) => (\n      <PersonTags\n        field=\"preferences\"\n        possibleTags={PERSON_PREFERENCES}\n        person={record}\n        colors={PREFERENCE_TO_COLOR}\n      />\n    ),\n    filters: arrayToAntdMappings(PERSON_PREFERENCES),\n    onFilter: (preference: string, record: Person) =>\n      arrayFilterByField(record, preference, \"preferences\")\n  },\n  {\n    title: \"מגמות רלוונטיות\",\n    dataIndex: \"megamut\",\n    key: \"megamut\",\n    render: (data: string[], record: Person) => (\n      <PersonTags\n        colors={MEGAMUT_TO_COLOR}\n        field=\"megamut\"\n        possibleTags={MEGAMUT}\n        person={record}\n      />\n    ),\n    filters: arrayToAntdMappings(MEGAMUT),\n    onFilter: (megama: string, record: Person) =>\n      arrayFilterByField(record, megama, \"megamut\")\n  },\n  {\n    title: \"מערכים רלוונטיים\",\n    dataIndex: \"subjects\",\n    key: \"subjects\",\n    render: (data: string[], record: Person) => (\n      <PersonTags field=\"subjects\" possibleTags={SUBJECTS} person={record} />\n    ),\n    filters: arrayToAntdMappings(SUBJECTS),\n    onFilter: (subject: string, record: Person) =>\n      arrayFilterByField(record, subject, \"subjects\")\n  },\n  {\n    title: \"סגל עבר\",\n    dataIndex: \"wasSegel\",\n    key: \"wasSegel\",\n    sorter: (firstPerson: Person, secondPerson: Person) =>\n      sortByField(firstPerson, secondPerson, \"wasSegel\"),\n    render: (wasSegel: string, record: Person) => (\n      <BooleanField field=\"wasSegel\" person={record} />\n    ),\n    filters: ANTD_BOOLEAN_FILTERS,\n    onFilter: (wasSegel: string, record: Person) =>\n      String(record.wasSegel) === wasSegel\n  },\n  {\n    title: \"הערות נוספות\",\n    dataIndex: \"remarks\",\n    key: \"remarks\",\n    width: \"30em\",\n    onFilter: (value: string, record: Person) =>\n      stringsFilterByField(record, value, \"remarks\"),\n    filterDropdown: TableTextFilter,\n    render: (value: string, record: Person) => (\n      <EditableText field=\"remarks\" person={record} initialValue={value} />\n    )\n  },\n  {\n    title: \"\",\n    dataIndex: \"\",\n    key: \"actions\",\n    render: (text: string, record: Person) => (\n      <PeopleTableDeleteButton person={record} />\n    )\n  }\n];\n","import React, { useContext } from \"react\";\nimport classNames from \"classnames\";\nimport { Table } from \"antd\";\n\nimport { PeopleTableColumns } from \"./PeopleTableColumns\";\nimport { PeopleContext } from \"../../contexts/PeopleContext\";\nimport \"./PeopleTable.scss\";\n\ninterface PeopleTableProps {\n  className?: String;\n}\n\nconst PeopleTable: React.FC<PeopleTableProps> = ({ className }) => {\n  const peopleContext = useContext(PeopleContext);\n  const data = peopleContext.people.map(person => ({\n    ...person,\n    key: person.id\n  }));\n  return (\n    <div className={classNames(className, \"people-table-container\")}>\n      <Table\n        dataSource={data}\n        columns={PeopleTableColumns(peopleContext)}\n        size=\"middle\"\n        pagination={{ pageSize: 30 }}\n      />\n    </div>\n  );\n};\n\nexport default PeopleTable;\n","import React, { useRef } from \"react\";\nimport { PlusOutlined } from \"@ant-design/icons\";\n\nimport \"./AddButton.scss\";\n\ninterface AddButtonProps {\n  onClick: () => void;\n}\n\nconst AddButton: React.FC<AddButtonProps> = ({ onClick }) => {\n  const buttonRef = useRef<HTMLButtonElement>(null);\n\n  const handleButton = () => {\n    /**\n     * We want to un focus the button once it was clicked in order\n     * to prevent accidental clicks when we press Enter for example.\n     */\n    if (buttonRef && buttonRef.current) {\n      buttonRef.current.blur();\n    }\n    onClick();\n  };\n\n  return (\n    /**\n     * This is a plain button and not Antd's Button because\n     * we need a way to blur the button once clicked.\n     */\n    <button\n      ref={buttonRef}\n      onClick={handleButton}\n      type=\"button\"\n      className=\"ant-btn add-button ant-btn-primary ant-btn-circle ant-btn-lg\"\n    >\n      <PlusOutlined />\n    </button>\n  );\n};\n\nexport default AddButton;\n","import React, { useState, useContext, KeyboardEvent } from \"react\";\nimport AddButton from \"../actions/AddButton\";\nimport { Modal, Form, Input, Radio, Checkbox, message } from \"antd\";\nimport {\n  PERSON_STATUSES,\n  AVAILABILITY,\n  PERSON_PREFERENCES,\n  SUBJECTS,\n  MEGAMUT,\n  MEGAMUT_TO_COLOR,\n  PREFERENCE_TO_COLOR\n} from \"../../consts\";\nimport TextArea from \"antd/lib/input/TextArea\";\nimport TagList from \"../tags/TagList\";\nimport { PeopleContext } from \"../../contexts/PeopleContext\";\nimport {\n  GET_PERSONAL_ID_RULES,\n  GET_BASIC_TEXT_RULES,\n  GET_PHONE_NUMBER_RULES\n} from \"../validators/validators\";\n\nconst layout = {\n  labelCol: { span: 5 },\n  wrapperCol: { span: 19 }\n};\n\nconst initialValues = {\n  fullName: \"\",\n  personId: \"\",\n  phone: \"\",\n  status: PERSON_STATUSES[0],\n  team: \"\",\n  preferences: [],\n  megamut: [],\n  subjects: [],\n  availability: AVAILABILITY[0],\n  wasSegel: false,\n  remarks: \"\"\n};\n\nconst AddPersonModal: React.FC = () => {\n  const [visible, setVisible] = useState(false);\n  const [form] = Form.useForm();\n  const { addPerson, doesPersonExist } = useContext(PeopleContext);\n\n  const showModal = () => {\n    setVisible(true);\n  };\n\n  const hideModal = () => {\n    setVisible(false);\n  };\n\n  const handleEnter = (event: KeyboardEvent<HTMLFormElement>) => {\n    if (event.key === \"Enter\") {\n      submitModal();\n    }\n  };\n\n  const submitModal = () => {\n    form\n      .validateFields()\n      .then(values => {\n        form.resetFields();\n        addPerson(values as any);\n        hideModal();\n        message.success(`${values.fullName} נוצר בהצלחה`);\n      })\n      .catch(() => {});\n  };\n\n  return (\n    <>\n      <AddButton onClick={showModal} />\n      <Modal\n        onOk={submitModal}\n        title=\"הוספת איש חוץ\"\n        visible={visible}\n        onCancel={hideModal}\n        okText=\"הוספה\"\n        cancelText=\"ביטול\"\n      >\n        <Form\n          {...layout}\n          size=\"small\"\n          form={form}\n          name=\"add_person_form\"\n          initialValues={initialValues}\n          onKeyDown={handleEnter}\n        >\n          <Form.Item\n            name=\"fullName\"\n            label=\"שם מלא\"\n            rules={GET_BASIC_TEXT_RULES()}\n          >\n            <Input />\n          </Form.Item>\n          <Form.Item\n            name=\"personalId\"\n            label=\"מ.א\"\n            rules={GET_PERSONAL_ID_RULES(doesPersonExist)}\n          >\n            <Input />\n          </Form.Item>\n          <Form.Item\n            name=\"phone\"\n            label=\"פלאפון\"\n            rules={GET_PHONE_NUMBER_RULES()}\n          >\n            <Input />\n          </Form.Item>\n          <Form.Item name=\"team\" label=\"צוות\">\n            <Input />\n          </Form.Item>\n          <Form.Item name=\"status\" label=\"מצב שירות\">\n            <Radio.Group>\n              {PERSON_STATUSES.map(status => (\n                <Radio key={status} value={status}>\n                  {status}\n                </Radio>\n              ))}\n            </Radio.Group>\n          </Form.Item>\n          <Form.Item name=\"availability\" label=\"זמינות\">\n            <Radio.Group>\n              {AVAILABILITY.map(availability => (\n                <Radio key={availability} value={availability}>\n                  {availability}\n                </Radio>\n              ))}\n            </Radio.Group>\n          </Form.Item>\n          <Form.Item name=\"wasSegel\" label=\"סגל עבר\" valuePropName=\"checked\">\n            <Checkbox />\n          </Form.Item>\n          <Form.Item name=\"preferences\" label=\"העדפות\" valuePropName=\"tags\">\n            <TagList\n              possibleTags={PERSON_PREFERENCES}\n              colors={PREFERENCE_TO_COLOR}\n              additionText=\"הוספת העדפה\"\n            />\n          </Form.Item>\n          <Form.Item name=\"megamut\" label=\"מגמות\" valuePropName=\"tags\">\n            <TagList\n              possibleTags={MEGAMUT}\n              colors={MEGAMUT_TO_COLOR}\n              additionText=\"הוספת מגמה\"\n            />\n          </Form.Item>\n          <Form.Item name=\"subjects\" label=\"מערכים\" valuePropName=\"tags\">\n            <TagList possibleTags={SUBJECTS} additionText=\"הוספת מערך\" />\n          </Form.Item>\n          <Form.Item name=\"remarks\" label=\"הערות נוספות\">\n            <TextArea />\n          </Form.Item>\n        </Form>\n      </Modal>\n    </>\n  );\n};\n\nexport default AddPersonModal;\n","import React from \"react\";\nimport { Layout, Menu } from \"antd\";\nimport { PeopleContextProvider } from \"./contexts/PeopleContext\";\nimport PeopleTable from \"./components/PeopleTable/PeopleTable\";\n\nimport \"antd/dist/antd.css\";\nimport \"./rtl.scss\";\nimport \"./App.scss\";\nimport AddPersonModal from \"./components/PeopleTable/AddPersonModal\";\n\nconst { Header, Content, Footer } = Layout;\n\nconst App: React.FC = () => {\n  return (\n    <Layout className=\"layout\">\n      <Header>\n        <div className=\"logo\" />\n        <Menu theme=\"dark\" mode=\"horizontal\" style={{ lineHeight: \"64px\" }}>\n          <Menu.Item> מנהל אנשי חוץ </Menu.Item>\n        </Menu>\n      </Header>\n      <Content>\n        <PeopleContextProvider>\n          <PeopleTable className=\"people-manager-table\" />\n          <AddPersonModal />\n        </PeopleContextProvider>\n      </Content>\n      <Footer>Bis Hibur ©2019 Created by Nir Geller</Footer>\n    </Layout>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}