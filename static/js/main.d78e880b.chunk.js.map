{"version":3,"sources":["types/person.ts","consts.ts","api/people.tsx","contexts/PeopleContext.tsx","components/filters/TableTextFilter.tsx","utils/sorters.ts","utils/filters.ts","components/tags/EditableTag.tsx","components/PeopleTable/PersonTag.tsx","components/actions/DeleteButton.tsx","components/text/EditableTextForm.tsx","components/text/EditableText.tsx","components/tags/AddTag.tsx","components/tags/TagList.tsx","components/PeopleTable/PersonTags.tsx","components/fields/BooleanField.tsx","components/validators/validators.ts","components/validators/consts.ts","components/text/EditableTextAutoComplete.tsx","components/PeopleTable/PeopleTableColumns.tsx","components/PeopleTable/PeopleTable.tsx","components/actions/AddButton.tsx","components/PeopleTable/AddPersonModal.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Person","args","id","fullName","personalId","phone","status","team","remarks","preferences","megamut","subjects","availability","wasSegel","this","PERSON_STATUSES","PERSON_PREFERENCES","MEGAMUT","SUBJECTS","AVAILABILITY","STATUS_TO_COLOR","אזרח","חייל","PREFERENCE_TO_COLOR","הרצאות","MEGAMUT_TO_COLOR","מערכות","מקורות","מחקר","AVAILABILITY_TO_COLOR","זמין","ANTD_BOOLEAN_FILTERS","text","value","getRandomNumberOfItemsFromList","data","slice","_","random","length","PeopleContext","createContext","people","deletePerson","personToDelete","getFieldDataSet","field","updatePerson","newPerson","addPerson","newPersonFields","doesPersonExist","personId","PeopleContextProvider","children","useState","setPeople","useEffect","range","map","sample","toString","find","Provider","filteredPeople","filter","person","fields","uniq","newPeople","TableTextFilter","setSelectedKeys","selectedKeys","confirm","clearFilters","className","ref","instance","focus","placeholder","onChange","e","newKeys","target","onPressEnter","type","onClick","icon","SearchOutlined","size","sortByField","firstPerson","secondPerson","stringsFilterByField","toLowerCase","includes","arrayFilterByField","arrayToAntdMappings","filters","EditableTag","possibleTags","color","onTagChange","onDelete","undefined","editing","setEditing","searchText","setSearchText","filteredTags","possibleTag","toggleEditing","tagProps","onClose","autoFocus","options","tag","onSelect","defaultOpen","onBlur","classNames","clickable","closable","PersonTag","colors","useContext","newTag","message","success","PeopleTableDeleteButton","title","onConfirm","error","okText","cancelText","placement","DeleteFilled","EditableTextForm","rules","currentValue","onSubmit","textClassName","useForm","form","initialValues","name","uniqueId","Item","validateFields","then","values","catch","EditableText","initialValue","InputType","Input","newValue","submitForm","onDoubleClick","event","key","shiftKey","handleEnterPress","AddTag","setFilter","newFilter","PlusOutlined","TagList","tags","additionText","unselectedTags","isEmpty","currentTag","tagToDelete","oldTag","FilteredTags","handleTagChange","PersonTags","newTags","BooleanField","checked","GET_PERSONAL_ID_RULES","required","validator","rule","Promise","reject","resolve","transform","toNumber","GET_BASIC_TEXT_RULES","character","onlyHebrewCharacters","GET_PHONE_NUMBER_RULES","min","EditableTextAutoComplete","dataSet","defaultValue","onKeyDown","handleKeyDown","PeopleTableColumns","dataIndex","sorter","onFilter","record","filterDropdown","render","width","currentAvailability","preference","megama","subject","String","TextArea","PeopleTable","peopleContext","dataSource","columns","pagination","pageSize","AddButton","buttonRef","useRef","current","blur","layout","labelCol","span","wrapperCol","AddPersonModal","visible","setVisible","Form","possibleTeams","hideModal","submitModal","resetFields","onOk","onCancel","label","stopPropagation","Group","valuePropName","Header","Layout","Content","Footer","App","theme","mode","style","lineHeight","Boolean","window","location","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.d78e880b.chunk.js","sourcesContent":["export interface PersonFields {\n  fullName: string;\n  personalId: string;\n  phone: string;\n  status: string;\n  team: string;\n  megamut: string[];\n  subjects: string[];\n  availability: string;\n  wasSegel?: boolean;\n  remarks?: string;\n  preferences?: string[];\n}\n\nexport class Person {\n  readonly id: string;\n  fullName: string;\n  personalId: string;\n  phone: string;\n  status: string;\n  team: string;\n  remarks: string;\n  preferences: string[];\n  megamut: string[];\n  subjects: string[];\n  availability: string;\n  wasSegel: boolean;\n\n  constructor(args: PersonFields) {\n    this.id = args.personalId;\n    this.fullName = args.fullName;\n    this.personalId = args.personalId;\n    this.phone = args.phone;\n    this.status = args.status;\n    this.team = args.team;\n    this.remarks = args.remarks || \"\";\n    this.preferences = args.preferences || [];\n    this.megamut = args.megamut || [];\n    this.subjects = args.subjects || [];\n    this.availability = args.availability || \"\";\n    this.wasSegel = args.wasSegel || false;\n  }\n}\n","export const PERSON_STATUSES = [\"אזרח\", \"חייל\"];\n\nexport const PERSON_PREFERENCES = [\"בדיקת תרגילים\", \"הרצאות\", \"להישאר לישון\"];\n\nexport const MEGAMUT = [\"מערכות\", \"מחקר\", \"מקורות\"];\n\nexport const SUBJECTS = [\"python\", \"C\", \"ביטים\"];\n\nexport const AVAILABILITY = [\"לא זמין\", \"זמין אבל עמוס\", \"זמין\"];\n\nexport const STATUS_TO_COLOR: {\n  [key: string]: string;\n} = {\n  אזרח: \"blue\",\n  חייל: \"green\"\n};\n\nexport const PREFERENCE_TO_COLOR: {\n  [key: string]: string;\n} = {\n  \"בדיקת תרגילים\": \"magenta\",\n  הרצאות: \"geekblue\",\n  \"להישאר לישון\": \"volcano\"\n};\n\nexport const MEGAMUT_TO_COLOR: {\n  [key: string]: string;\n} = {\n  מערכות: \"green\",\n  מקורות: \"orange\",\n  מחקר: \"purple\"\n};\n\nexport const AVAILABILITY_TO_COLOR = {\n  \"לא זמין\": \"red\",\n  \"זמין אבל עמוס\": \"orange\",\n  זמין: \"green\"\n};\n\n/**\n * Filters for the antd table component that correspond to boolean fields.\n */\nexport const ANTD_BOOLEAN_FILTERS = [\n  {\n    text: \"כן\",\n    value: \"true\"\n  },\n  {\n    text: \"לא\",\n    value: \"false\"\n  }\n];\n\nexport const EDIT_SUCCESS_MESSAGE = \"שדה עודכן בהצלחה.\";\n","import _ from \"lodash\";\n\nimport { Person } from \"../types/person\";\nimport {\n  PERSON_PREFERENCES,\n  PERSON_STATUSES,\n  MEGAMUT,\n  SUBJECTS,\n  AVAILABILITY\n} from \"../consts\";\n\nconst getRandomNumberOfItemsFromList = (data: any[]) =>\n  data.slice(0, _.random(0, data.length));\n\nexport const getPeople = (): Person[] =>\n  _.range(1000).map(\n    id =>\n      new Person({\n        team: \"פיירו\",\n        status: _.sample(PERSON_STATUSES) || PERSON_STATUSES[0],\n        phone: \"053-0000000\",\n        personalId: _.random(10000000, 99999999).toString(),\n        fullName: \"ניר גלר\" + _.random(1, 100).toString(),\n        remarks: \"ששדגדשג\",\n        preferences: getRandomNumberOfItemsFromList(PERSON_PREFERENCES),\n        megamut: getRandomNumberOfItemsFromList(MEGAMUT),\n        subjects: getRandomNumberOfItemsFromList(SUBJECTS),\n        availability: _.sample(AVAILABILITY) || AVAILABILITY[0],\n        wasSegel: _.sample([true, false])\n      })\n  );\n","import React, { createContext, useEffect, useState } from \"react\";\nimport { getPeople } from \"../api/people\";\nimport { Person, PersonFields } from \"../types/person\";\nimport _ from \"lodash\";\n\nexport interface PeopleContextInterface {\n  people: Person[];\n  deletePerson: (personToDelete: Person) => boolean;\n  getFieldDataSet: (field: keyof Person) => any[];\n  updatePerson: (newPerson: Person) => void;\n  addPerson: (newPersonFields: PersonFields) => void;\n  doesPersonExist: (personId: string) => boolean;\n}\n\nconst defaultData: PeopleContextInterface = {\n  people: [],\n  deletePerson: (personToDelete: Person) => true,\n  getFieldDataSet: (field: keyof Person) => [],\n  updatePerson: (newPerson: Person) => {},\n  addPerson: (newPersonFields: PersonFields) => {},\n  doesPersonExist: (personId: string) => false\n};\n\nexport const PeopleContext = createContext(defaultData);\n\n/**\n * A context which handles all of the manipulation on the people dataset.\n * From fetching the data set to deleting or adding people.\n */\nexport const PeopleContextProvider: React.FC = ({ children }) => {\n  const [people, setPeople]: [Person[], Function] = useState([]);\n\n  useEffect(() => {\n    setPeople(getPeople());\n  }, []);\n\n  /**\n   * Check if we already have a person with this id.\n   * @param personId The id of the person.\n   */\n  const doesPersonExist = (personId: string) =>\n    !!_.find(people, [\"id\", personId]);\n\n  /**\n   * Deletes a specific person identified by id.\n   *\n   * @param personToDelete The person to delete from the dataset.\n   * @returns a boolean indicating the success of the operation.\n   */\n  const deletePerson = (personToDelete: Person): boolean => {\n    if (doesPersonExist(personToDelete.id)) {\n      const filteredPeople = people.filter(\n        person => person.id !== personToDelete.id\n      );\n      setPeople(filteredPeople);\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  /**\n   * Retrieves all of the unique values of a given field.\n   * @param field The field from which the data set should be built\n   */\n  const getFieldDataSet = (field: keyof Person) => {\n    const fields = people.map((person: Person) => person[field]);\n    return _.uniq(fields);\n  };\n\n  /**\n   * Update a specific person.\n   */\n  const updatePerson = (newPerson: Person) => {\n    const newPeople = [\n      ...people.map(person => (person.id === newPerson.id ? newPerson : person))\n    ];\n    setPeople(newPeople);\n  };\n\n  /**\n   * Create new Person\n   */\n  const addPerson = (newPersonFields: PersonFields) => {\n    setPeople([...people, new Person(newPersonFields)]);\n  };\n\n  return (\n    <PeopleContext.Provider\n      value={{\n        doesPersonExist,\n        addPerson,\n        people,\n        deletePerson,\n        getFieldDataSet,\n        updatePerson\n      }}\n    >\n      {children}\n    </PeopleContext.Provider>\n  );\n};\n","import React from \"react\";\nimport { Input, Button } from \"antd\";\nimport { SearchOutlined } from \"@ant-design/icons\";\n\nimport \"./TableTextFilter.scss\";\n\ninterface TableTextFilterProps {\n  setSelectedKeys: (newFilters: string[]) => void;\n  selectedKeys: string[];\n  confirm: () => void;\n  clearFilters: () => void;\n}\n\nconst TableTextFilter: React.FC<TableTextFilterProps> = ({\n  setSelectedKeys,\n  selectedKeys,\n  confirm,\n  clearFilters\n}) => {\n  const onSearch = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const newKeys = e.target.value ? [e.target.value] : [];\n    setSelectedKeys(newKeys);\n  };\n\n  return (\n    <div className=\"table-filter\">\n      <Input\n        ref={(instance: Input) => {\n          if (instance) {\n            instance.focus();\n          }\n        }}\n        placeholder={`הכנס את החיפוש`}\n        value={selectedKeys[0]}\n        onChange={onSearch}\n        className=\"search-input\"\n        onPressEnter={confirm}\n      />\n      <Button\n        type=\"primary\"\n        onClick={confirm}\n        icon={<SearchOutlined />}\n        size=\"small\"\n        className=\"search-button\"\n      >\n        חפש\n      </Button>\n      <Button onClick={clearFilters} size=\"small\" className=\"clear-button\">\n        נקה חיפוש\n      </Button>\n    </div>\n  );\n};\n\nexport default TableTextFilter;\n","import { Person } from \"../types/person\";\n\n/**\n * Compares between two person objects by a specific field.\n * @param firstPerson\n * @param secondPerson\n * @param field The field name by which the objects should be compared\n */\nexport const sortByField = (\n  firstPerson: Person,\n  secondPerson: Person,\n  field: keyof Person\n): number => {\n  if (firstPerson[field] > secondPerson[field]) {\n    return 1;\n  } else if (firstPerson[field] < secondPerson[field]) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\n","import { Person } from \"../types/person\";\nimport { ConditionalProps, getElementType } from \"./types\";\nimport moment, { Moment } from \"moment\";\n\n/**\n * Checks if the person value of the property key contains the given value.\n * Please notice: the check ignores case.\n * @param person The person that should be filtered.\n * @param text The value that should be part of the fields value.\n * @param field The field to check against\n */\nexport const stringsFilterByField = (\n  person: Person,\n  text: string,\n  field: ConditionalProps<Person, string>\n) => person[field].toLowerCase().includes(text.toLowerCase());\n\n/**\n * Checks wether the persons date field is within the range given.\n * Please notice the range is inclusive on both ends (since and until).\n * @param person The person that should be filtered.\n * @param datesRange The dates range by which we will filter\n * @param field The date field that will be filtered.\n */\nexport const datesFilterByField = (\n  person: Person,\n  datesRange: { since: Moment; until: Moment },\n  field: ConditionalProps<Person, moment.Moment>\n) =>\n  datesRange.since.startOf(\"day\") <= person[field] &&\n  person[field] <= datesRange.until.endOf(\"day\");\n\nexport function arrayFilterByField<\n  K extends ConditionalProps<Person, Array<any>>\n>(person: Person, value: getElementType<Person[K]>, field: K) {\n  return (person[field] as any).includes(value);\n}\n\n/**\n * Convert an array of literals to antd filters format.\n * @param filters\n */\nexport const arrayToAntdMappings = (filters: string[]) =>\n  filters.map((value: string) => ({\n    text: value,\n    value\n  }));\n","import React, { useState } from \"react\";\nimport { AutoComplete, Tag } from \"antd\";\nimport { SelectValue } from \"antd/lib/select\";\nimport { TagProps } from \"antd/lib/tag\";\nimport classNames from \"classnames\";\n\ninterface EditableTagProps extends TagProps {\n  possibleTags: string[];\n  color?: string;\n  onTagChange: (newTag: string) => void;\n  onDelete?: () => void;\n}\n\n/**\n * An editable tag with multiple functionalities.\n * In case the tag can be deleted entirely and not only changed please pass a function\n * to handle that case to the onDelete prop.\n *\n * Please notice:\n * In case the tag can be deleted, clicking the tag will prompt the user to change\n * its value while clicking the close icon will delete the tag.\n *\n * In case the tag can't be deleted only clicking the close icon will prompt the user\n * to change the tags value.\n */\nconst EditableTag: React.FC<EditableTagProps> = ({\n  possibleTags,\n  color = \"\",\n  onTagChange,\n  children,\n  onDelete = undefined\n}) => {\n  const [editing, setEditing] = useState(false);\n  const [searchText, setSearchText] = useState(\"\");\n  const filteredTags = possibleTags.filter(possibleTag =>\n    possibleTag.includes(searchText)\n  );\n\n  const toggleEditing = () => {\n    setEditing(!editing);\n    setSearchText(\"\");\n  };\n\n  const handleSelection = (value: SelectValue) => {\n    onTagChange(value.toString());\n    toggleEditing();\n  };\n\n  const handleChange = (value: SelectValue) => {\n    setSearchText(value.toString());\n  };\n\n  const tagProps = onDelete\n    ? {\n        onClose: onDelete,\n        onClick: toggleEditing\n      }\n    : {\n        onClose: toggleEditing\n      };\n\n  return editing ? (\n    <AutoComplete\n      autoFocus\n      onChange={handleChange}\n      options={filteredTags.map(tag => ({ value: tag }))}\n      onSelect={handleSelection}\n      defaultOpen\n      onBlur={toggleEditing}\n      value={searchText}\n    />\n  ) : (\n    <Tag\n      className={classNames({ clickable: onDelete })}\n      color={color}\n      closable\n      {...tagProps}\n    >\n      {children}\n    </Tag>\n  );\n};\n\nexport default EditableTag;\n","import React, { useContext } from \"react\";\nimport EditableTag from \"../tags/EditableTag\";\nimport { PeopleContext } from \"../../contexts/PeopleContext\";\nimport { Person } from \"../../types/person\";\nimport { ConditionalProps } from \"../../utils/types\";\nimport { message } from \"antd\";\nimport { EDIT_SUCCESS_MESSAGE } from \"../../consts\";\n\nexport interface PersonTag {\n  person: Person;\n  field: ConditionalProps<Person, string>;\n  colors?: {\n    [color: string]: string;\n  };\n  possibleTags: string[];\n}\n\nconst PersonTag: React.FC<PersonTag> = ({\n  person,\n  field,\n  colors = {},\n  possibleTags\n}) => {\n  const { updatePerson } = useContext(PeopleContext);\n\n  const handleTagChange = (newTag: string) => {\n    const newPerson = {\n      ...person,\n      [field]: newTag\n    };\n    updatePerson(newPerson);\n    message.success(EDIT_SUCCESS_MESSAGE);\n  };\n\n  return (\n    <EditableTag\n      onTagChange={handleTagChange}\n      possibleTags={possibleTags}\n      color={colors[person[field]]}\n    >\n      {person[field]}\n    </EditableTag>\n  );\n};\n\nexport default PersonTag;\n","import React, { useContext } from \"react\";\nimport { message, Popconfirm } from \"antd\";\nimport { DeleteFilled } from \"@ant-design/icons\";\nimport { PeopleContext } from \"../../contexts/PeopleContext\";\nimport { Person } from \"../../types/person\";\n\nimport \"./DeleteButton.scss\";\n\ninterface PeopleTableDeleteButtonProps {\n  person: Person;\n}\n\n/**\n * A delete button specific for the peoples data table.\n */\nconst PeopleTableDeleteButton: React.FC<PeopleTableDeleteButtonProps> = ({\n  person\n}) => {\n  const { deletePerson } = useContext(PeopleContext);\n\n  const handlePersonDeletion = () => {\n    if (deletePerson(person)) {\n      message.success(`${person.fullName} נמחק בהצלחה!`);\n    } else {\n      message.error(`לא ניתן למחוק את ${person.fullName}`);\n    }\n  };\n\n  return (\n    <Popconfirm\n      title={`האם למחוק את ${person.fullName}?`}\n      onConfirm={handlePersonDeletion}\n      okText=\"כן\"\n      cancelText=\"לא\"\n      placement=\"right\"\n    >\n      <DeleteFilled />\n    </Popconfirm>\n  );\n};\n\nexport default PeopleTableDeleteButton;\n","import React, { useState } from \"react\";\nimport { Form } from \"antd\";\nimport { useForm } from \"antd/lib/form/Form\";\nimport { Rule, FormItemProps } from \"antd/lib/form\";\nimport _ from \"lodash\";\nimport classNames from \"classnames\";\n\nimport \"./EditableTextForm.scss\";\n\ninterface EditableTextFormProps {\n  rules: Rule[];\n  currentValue: string;\n  children: (\n    submitForm: () => void,\n    toggleEditing: () => void\n  ) => FormItemProps[\"children\"];\n  onSubmit: (newValue: string) => void;\n  textClassName?: string;\n}\n\n/**\n * A generic component for editing text.\n * The component expects to receive the input method (For example <Input> or <AutoComplete>) as\n * its children (See the props interface).\n * The children receive two functions in order to allow more control over the form from the inputs element side:\n * 1. submitForm - When this function is called the form will be validated and submitted.\n * 2. toggleEditing - Calling this function will toggle the editing state of the form, please note that submitForm already closes the editor.\n *\n * Please Notice:\n * Your input must have the props value and onChange.\n */\nconst EditableTextForm: React.FC<EditableTextFormProps> = ({\n  children,\n  rules,\n  currentValue,\n  onSubmit,\n  textClassName\n}) => {\n  const [editing, setEditing] = useState(false);\n  const [form] = useForm();\n\n  const toggleEditing = () => {\n    setEditing(!editing);\n  };\n\n  const handleSubmit = () => {\n    form\n      .validateFields()\n      .then(values => {\n        onSubmit(values.text);\n        setEditing(false);\n      })\n      .catch(() => {});\n  };\n\n  return editing ? (\n    <Form\n      initialValues={{ text: currentValue }}\n      name={_.uniqueId(\"editable_text_form_\")}\n      form={form}\n    >\n      <Form.Item name=\"text\" rules={rules}>\n        {children(handleSubmit, toggleEditing)}\n      </Form.Item>\n    </Form>\n  ) : (\n    <span\n      className={classNames(textClassName, \"editable-field clickable\")}\n      onClick={toggleEditing}\n    >\n      {currentValue}\n    </span>\n  );\n};\n\nexport default EditableTextForm;\n","import React, { useContext, KeyboardEvent } from \"react\";\nimport { message, Input } from \"antd\";\nimport { Person } from \"../../types/person\";\nimport { PeopleContext } from \"../../contexts/PeopleContext\";\nimport { ConditionalProps } from \"../../utils/types\";\n\nimport { EDIT_SUCCESS_MESSAGE } from \"../../consts\";\nimport { Rule } from \"antd/lib/form\";\nimport EditableTextForm from \"./EditableTextForm\";\nimport TextArea from \"antd/lib/input/TextArea\";\n\ninterface PeopleTableEditableTextProps {\n  initialValue: string;\n  field: ConditionalProps<Person, string>;\n  person: Person;\n  rules?: Rule[];\n  InputType?: typeof Input | typeof TextArea;\n  textClassName?: string;\n}\n\ntype InputEventType =\n  | KeyboardEvent<HTMLInputElement>\n  | KeyboardEvent<HTMLTextAreaElement>;\n\nconst EditableText: React.FC<PeopleTableEditableTextProps> = ({\n  field,\n  person,\n  initialValue,\n  rules = [],\n  InputType = Input,\n  textClassName = \"\"\n}) => {\n  const { updatePerson } = useContext(PeopleContext);\n\n  const handleTextChange = (newValue: string) => {\n    updatePerson({ ...person, [field]: newValue });\n    message.success(EDIT_SUCCESS_MESSAGE);\n  };\n\n  /**\n   * We want to submit the form only when enter is pressed in order to allow\n   * the insertion of line breaks.\n   * Currently you can insert a line break with shift + enter.\n   */\n  const handleEnterPress = (event: InputEventType, submitForm: () => void) => {\n    if (event.key === \"Enter\" && !event.shiftKey) {\n      submitForm();\n    }\n  };\n\n  return (\n    <EditableTextForm\n      rules={rules}\n      currentValue={initialValue}\n      onSubmit={handleTextChange}\n      textClassName={textClassName}\n    >\n      {(submitForm, toggleEditing) => (\n        <InputType\n          onDoubleClick={toggleEditing}\n          autoFocus\n          onBlur={toggleEditing}\n          onPressEnter={(event: InputEventType) =>\n            handleEnterPress(event, submitForm)\n          }\n        />\n      )}\n    </EditableTextForm>\n  );\n};\n\nexport default EditableText;\n","import React, { useState, useEffect } from \"react\";\nimport { AutoComplete, Tag } from \"antd\";\nimport { PlusOutlined } from \"@ant-design/icons\";\nimport { SelectValue } from \"antd/lib/select\";\n\nimport \"./AddTag.scss\";\n\ninterface AddTagProps {\n  possibleTags: string[];\n  onSubmit: (newTag: string) => void;\n  text: string;\n}\n\nconst AddTag: React.FC<AddTagProps> = ({ possibleTags, onSubmit, text }) => {\n  const [editing, setEditing] = useState(false);\n  const [filter, setFilter] = useState(\"\");\n  const filteredTags = possibleTags.filter(tag => tag.includes(filter));\n\n  /**\n   * We want a fresh filter each time we enter or exit the filtering state.\n   */\n  useEffect(() => {\n    setFilter(\"\");\n  }, [editing]);\n\n  /**\n   * Handle the selection of a value from the auto complete.\n   * @param value\n   */\n  const handleSelection = (value: SelectValue) => {\n    setEditing(false);\n    onSubmit(value.toString());\n  };\n\n  const toggleEditing = () => {\n    setEditing(!editing);\n  };\n\n  const handleChange = (newFilter: SelectValue) => {\n    setFilter(newFilter.toString());\n  };\n\n  return editing ? (\n    <AutoComplete\n      onChange={handleChange}\n      autoFocus\n      defaultOpen\n      options={filteredTags.map(tag => ({ value: tag }))}\n      onSelect={handleSelection}\n      onBlur={toggleEditing}\n    />\n  ) : (\n    <Tag onClick={toggleEditing} className=\"clickable add-tag\">\n      <PlusOutlined /> {text}\n    </Tag>\n  );\n};\n\nexport default AddTag;\n","import React from \"react\";\nimport AddTag from \"./AddTag\";\n\nimport \"./TagList.scss\";\nimport _ from \"lodash\";\nimport EditableTag from \"./EditableTag\";\n\ninterface TagListProps {\n  tags?: string[];\n  possibleTags: string[];\n  colors?: {\n    [color: string]: string;\n  };\n  additionText: string;\n  onChange?: (newTags: string[]) => void;\n}\n\nconst TagList: React.FC<TagListProps> = ({\n  tags = [],\n  possibleTags,\n  colors = {},\n  onChange = () => {},\n  additionText\n}) => {\n  let unselectedTags = possibleTags.filter(tag => !tags.includes(tag));\n\n  const handleTagDeletion = (tagToDelete: string) => {\n    onChange(tags.filter(tag => tag !== tagToDelete));\n  };\n\n  const handleTagAddition = (newTag: string) => {\n    onChange([...tags, newTag]);\n  };\n\n  const handleTagChange = (oldTag: string, newTag: string) => {\n    const FilteredTags = tags.filter(tag => tag !== oldTag);\n    onChange([...FilteredTags, newTag]);\n  };\n\n  /**\n   * We want the current value of the tag to be a possible tag that the user\n   * can change the current value to because of the following:\n   * In case there are no other options (All of the possibleTags are selected) when a person\n   * clicks a tag to edit it its weird that there are no options, it looks a lot better\n   * if the current value is available.\n   * @param currentTag The current value of the editable tag.\n   */\n  const getEditableTagPossibleTags = (currentTag: string) => [\n    ...unselectedTags,\n    currentTag\n  ];\n\n  return (\n    <div className=\"tag-list\">\n      {tags.map(tag => (\n        <EditableTag\n          color={_.isEmpty(colors) ? \"\" : colors[tag]}\n          key={tag}\n          possibleTags={getEditableTagPossibleTags(tag)}\n          onDelete={() => handleTagDeletion(tag)}\n          onTagChange={(newTag: string) => handleTagChange(tag, newTag)}\n          closable\n        >\n          {tag}\n        </EditableTag>\n      ))}\n      {unselectedTags.length > 0 && (\n        <AddTag\n          text={additionText}\n          possibleTags={unselectedTags}\n          onSubmit={handleTagAddition}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default TagList;\n","import React, { useContext } from \"react\";\nimport { Person } from \"../../types/person\";\nimport { PeopleContext } from \"../../contexts/PeopleContext\";\nimport TagList from \"../tags/TagList\";\nimport { ConditionalProps } from \"../../utils/types\";\nimport { message } from \"antd\";\nimport { EDIT_SUCCESS_MESSAGE } from \"../../consts\";\n\ninterface PersonPreferenceTagsProps {\n  person: Person;\n  field: ConditionalProps<Person, Array<any>>;\n  possibleTags: string[];\n  colors?: {\n    [color: string]: string;\n  };\n}\n\nconst PersonTags: React.FC<PersonPreferenceTagsProps> = ({\n  person,\n  field,\n  possibleTags,\n  colors = {}\n}) => {\n  const { updatePerson } = useContext(PeopleContext);\n\n  /**\n   * Add the new tag to the current person\n   * @param value\n   */\n  const handleTagsChange = (newTags: string[]) => {\n    const newPerson = {\n      ...person,\n      [field]: newTags\n    };\n    updatePerson(newPerson);\n    message.success(EDIT_SUCCESS_MESSAGE);\n  };\n\n  return (\n    <TagList\n      tags={person[field]}\n      colors={colors}\n      possibleTags={possibleTags}\n      onChange={handleTagsChange}\n      additionText=\"הוספת העדפה\"\n    />\n  );\n};\n\nexport default PersonTags;\n","import React, { useContext } from \"react\";\nimport { Person } from \"../../types/person\";\nimport { ConditionalProps } from \"../../utils/types\";\nimport { PeopleContext } from \"../../contexts/PeopleContext\";\nimport { message, Checkbox } from \"antd\";\nimport { EDIT_SUCCESS_MESSAGE } from \"../../consts\";\n\ninterface BooleanFieldProps {\n  person: Person;\n  field: ConditionalProps<Person, boolean>;\n}\n\nconst BooleanField: React.FC<BooleanFieldProps> = ({ person, field }) => {\n  const { updatePerson } = useContext(PeopleContext);\n\n  const handleClick = () => {\n    const newPerson = {\n      ...person,\n      [field]: !person[field]\n    };\n    updatePerson(newPerson);\n    message.success(EDIT_SUCCESS_MESSAGE);\n  };\n\n  return (\n    <Checkbox\n      checked={person[field]}\n      className=\"clickable\"\n      onClick={handleClick}\n    />\n  );\n};\n\nexport default BooleanField;\n","import { ALLOWED_CHARACTERS, MIN_PHONE_LENGTH } from \"./consts\";\nimport _ from \"lodash\";\nimport { Rule } from \"antd/lib/form\";\n\n/**\n * Checks if value contains only hebrew characters\n * @param value The string to check.\n */\nexport const onlyHebrewCharacters = (value: string): boolean => {\n  for (const character of value) {\n    if (!ALLOWED_CHARACTERS.includes(character)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// From here down you can find antd rules for validating fields.\n\nexport const GET_PERSONAL_ID_RULES = (doesPersonExist: Function): Rule[] => [\n  { required: true, message: \"בבקשה הכנס מספר אישי\" },\n  {\n    validator(rule: any, value: string) {\n      if (!doesPersonExist(value)) {\n        return Promise.resolve();\n      } else {\n        return Promise.reject(\"כבר יש איש חוץ עם המספר אישי הזה\");\n      }\n    }\n  },\n  {\n    message: \"המספר אישי חייב להכיל רק מספרים\",\n    transform: (value: string) => _.toNumber(value),\n    type: \"number\"\n  }\n];\n\nexport const GET_BASIC_TEXT_RULES = (): Rule[] => [\n  { required: true, message: \"בבקשה הכנס שם מלא\" },\n  {\n    validator(rule, value) {\n      if (onlyHebrewCharacters(value)) {\n        return Promise.resolve();\n      } else {\n        return Promise.reject(\"השם חייב להכין רק תווים בעברית או רווח\");\n      }\n    }\n  }\n];\n\nexport const GET_PHONE_NUMBER_RULES = (): Rule[] => [\n  {\n    required: true,\n    message: \"בבקשה הכנס מספר פלאפון\"\n  },\n  {\n    message: \"המספר פלאפון חייב להכיל רק מספרים\",\n    transform: value => _.toNumber(value),\n    type: \"number\"\n  },\n  {\n    message: `המספר פלאפון חייב להכין לפחות ${MIN_PHONE_LENGTH} תוים`,\n    min: MIN_PHONE_LENGTH\n  }\n];\n","export const MIN_PHONE_LENGTH = 7;\n\nexport const ALLOWED_CHARACTERS = \"אבגדהוזחטיכךלמםנןסעפףצץקרשת \";\n","import React, { useContext, KeyboardEvent } from \"react\";\nimport { message, AutoComplete } from \"antd\";\nimport { Person } from \"../../types/person\";\nimport { PeopleContext } from \"../../contexts/PeopleContext\";\nimport { ConditionalProps } from \"../../utils/types\";\n\nimport { EDIT_SUCCESS_MESSAGE } from \"../../consts\";\nimport { Rule } from \"antd/lib/form\";\nimport EditableTextForm from \"./EditableTextForm\";\n\ninterface EditableTextAutoCompleteProps {\n  initialValue: string;\n  field: ConditionalProps<Person, string>;\n  person: Person;\n  rules?: Rule[];\n}\n\nconst EditableTextAutoComplete: React.FC<EditableTextAutoCompleteProps> = ({\n  field,\n  person,\n  initialValue,\n  rules = []\n}) => {\n  const { updatePerson, getFieldDataSet } = useContext(PeopleContext);\n  const dataSet = getFieldDataSet(field);\n\n  const handleTextSelection = (newValue: string) => {\n    updatePerson({ ...person, [field]: newValue });\n    message.success(EDIT_SUCCESS_MESSAGE);\n  };\n\n  const handleKeyDown = (\n    event: KeyboardEvent<HTMLDivElement>,\n    submitForm: () => void\n  ) => {\n    if (event.key === \"Enter\") {\n      submitForm();\n    }\n  };\n\n  return (\n    <EditableTextForm\n      rules={rules}\n      currentValue={initialValue}\n      onSubmit={handleTextSelection}\n    >\n      {(submitForm, toggleEditing) => (\n        <AutoComplete\n          options={dataSet.map(data => ({ value: data }))}\n          defaultValue={initialValue}\n          autoFocus\n          onBlur={toggleEditing}\n          onSelect={submitForm}\n          onKeyDown={event => handleKeyDown(event, submitForm)}\n        />\n      )}\n    </EditableTextForm>\n  );\n};\n\nexport default EditableTextAutoComplete;\n","import React from \"react\";\n\nimport TableTextFilter from \"../filters/TableTextFilter\";\nimport { sortByField } from \"../../utils/sorters\";\nimport {\n  stringsFilterByField,\n  arrayToAntdMappings,\n  arrayFilterByField\n} from \"../../utils/filters\";\nimport { Person } from \"../../types/person\";\nimport PersonTag from \"./PersonTag\";\nimport PeopleTableDeleteButton from \"../actions/DeleteButton\";\nimport EditableText from \"../text/EditableText\";\nimport PersonTags from \"./PersonTags\";\nimport {\n  PERSON_STATUSES,\n  PERSON_PREFERENCES,\n  MEGAMUT,\n  PREFERENCE_TO_COLOR,\n  MEGAMUT_TO_COLOR,\n  SUBJECTS,\n  STATUS_TO_COLOR,\n  AVAILABILITY_TO_COLOR,\n  AVAILABILITY,\n  ANTD_BOOLEAN_FILTERS\n} from \"../../consts\";\nimport BooleanField from \"../fields/BooleanField\";\nimport {\n  GET_PERSONAL_ID_RULES,\n  GET_BASIC_TEXT_RULES,\n  GET_PHONE_NUMBER_RULES\n} from \"../validators/validators\";\nimport { PeopleContextInterface } from \"../../contexts/PeopleContext\";\nimport EditableTextAutoComplete from \"../text/EditableTextAutoComplete\";\nimport { Input } from \"antd\";\n\nexport const PeopleTableColumns = ({\n  doesPersonExist\n}: PeopleContextInterface) => [\n  {\n    title: \"שם מלא\",\n    dataIndex: \"fullName\",\n    key: \"fullName\",\n    sorter: (firstPerson: Person, secondPerson: Person) =>\n      sortByField(firstPerson, secondPerson, \"fullName\"),\n    onFilter: (value: string, record: Person) =>\n      stringsFilterByField(record, value, \"fullName\"),\n    filterDropdown: TableTextFilter,\n    render: (value: string, record: Person) => (\n      <EditableText\n        field=\"fullName\"\n        person={record}\n        initialValue={value}\n        rules={GET_BASIC_TEXT_RULES()}\n      />\n    ),\n    width: \"15em\"\n  },\n  {\n    title: \"מ.א\",\n    dataIndex: \"personalId\",\n    key: \"personalId\",\n    sorter: (firstPerson: Person, secondPerson: Person) =>\n      sortByField(firstPerson, secondPerson, \"personalId\"),\n    onFilter: (value: string, record: Person) =>\n      stringsFilterByField(record, value, \"personalId\"),\n    filterDropdown: TableTextFilter,\n    render: (value: string, record: Person) => (\n      <EditableText\n        field=\"personalId\"\n        person={record}\n        initialValue={value}\n        rules={GET_PERSONAL_ID_RULES(doesPersonExist)}\n      />\n    ),\n    width: \"15em\"\n  },\n  {\n    title: \"פלאפון\",\n    dataIndex: \"phone\",\n    key: \"phone\",\n    render: (value: string, record: Person) => (\n      <EditableText\n        field=\"phone\"\n        person={record}\n        initialValue={value}\n        rules={GET_PHONE_NUMBER_RULES()}\n      />\n    ),\n    width: \"12em\"\n  },\n  {\n    title: \"מצב שירות\",\n    dataIndex: \"status\",\n    sorter: (firstPerson: Person, secondPerson: Person) =>\n      sortByField(firstPerson, secondPerson, \"status\"),\n    key: \"status\",\n    render: (status: string, record: Person) => (\n      <PersonTag\n        field=\"status\"\n        possibleTags={PERSON_STATUSES}\n        colors={STATUS_TO_COLOR}\n        person={record}\n      />\n    ),\n    filters: arrayToAntdMappings(PERSON_STATUSES),\n    onFilter: (status: string, record: Person) => record.status === status\n  },\n  {\n    title: \"זמינות\",\n    dataIndex: \"availability\",\n    key: \"availability\",\n    sorter: (firstPerson: Person, secondPerson: Person) =>\n      sortByField(firstPerson, secondPerson, \"availability\"),\n    render: (currentAvailability: string, record: Person) => (\n      <PersonTag\n        field=\"availability\"\n        possibleTags={AVAILABILITY}\n        colors={AVAILABILITY_TO_COLOR}\n        person={record}\n      />\n    ),\n    filters: arrayToAntdMappings(AVAILABILITY),\n    onFilter: (availability: string, record: Person) =>\n      record.availability === availability\n  },\n  {\n    title: \"צוות\",\n    dataIndex: \"team\",\n    key: \"team\",\n    sorter: (firstPerson: Person, secondPerson: Person) =>\n      sortByField(firstPerson, secondPerson, \"team\"),\n    onFilter: (value: string, record: Person) =>\n      stringsFilterByField(record, value, \"team\"),\n    filterDropdown: TableTextFilter,\n    render: (value: string, record: Person) => (\n      <EditableTextAutoComplete\n        field=\"team\"\n        person={record}\n        initialValue={value}\n      />\n    ),\n    width: \"12em\"\n  },\n  {\n    title: \"העדפות\",\n    dataIndex: \"preferences\",\n    key: \"preferences\",\n    render: (data: string[], record: Person) => (\n      <PersonTags\n        field=\"preferences\"\n        possibleTags={PERSON_PREFERENCES}\n        person={record}\n        colors={PREFERENCE_TO_COLOR}\n      />\n    ),\n    filters: arrayToAntdMappings(PERSON_PREFERENCES),\n    onFilter: (preference: string, record: Person) =>\n      arrayFilterByField(record, preference, \"preferences\")\n  },\n  {\n    title: \"מגמות רלוונטיות\",\n    dataIndex: \"megamut\",\n    key: \"megamut\",\n    render: (data: string[], record: Person) => (\n      <PersonTags\n        colors={MEGAMUT_TO_COLOR}\n        field=\"megamut\"\n        possibleTags={MEGAMUT}\n        person={record}\n      />\n    ),\n    filters: arrayToAntdMappings(MEGAMUT),\n    onFilter: (megama: string, record: Person) =>\n      arrayFilterByField(record, megama, \"megamut\")\n  },\n  {\n    title: \"מערכים רלוונטיים\",\n    dataIndex: \"subjects\",\n    key: \"subjects\",\n    render: (data: string[], record: Person) => (\n      <PersonTags field=\"subjects\" possibleTags={SUBJECTS} person={record} />\n    ),\n    filters: arrayToAntdMappings(SUBJECTS),\n    onFilter: (subject: string, record: Person) =>\n      arrayFilterByField(record, subject, \"subjects\")\n  },\n  {\n    title: \"סגל עבר\",\n    dataIndex: \"wasSegel\",\n    key: \"wasSegel\",\n    sorter: (firstPerson: Person, secondPerson: Person) =>\n      sortByField(firstPerson, secondPerson, \"wasSegel\"),\n    render: (wasSegel: string, record: Person) => (\n      <BooleanField field=\"wasSegel\" person={record} />\n    ),\n    filters: ANTD_BOOLEAN_FILTERS,\n    onFilter: (wasSegel: string, record: Person) =>\n      String(record.wasSegel) === wasSegel\n  },\n  {\n    title: \"הערות נוספות\",\n    dataIndex: \"remarks\",\n    key: \"remarks\",\n    width: \"30em\",\n    onFilter: (value: string, record: Person) =>\n      stringsFilterByField(record, value, \"remarks\"),\n    filterDropdown: TableTextFilter,\n    render: (value: string, record: Person) => (\n      <EditableText\n        textClassName=\"remarks-text\"\n        InputType={Input.TextArea}\n        field=\"remarks\"\n        person={record}\n        initialValue={value}\n      />\n    )\n  },\n  {\n    title: \"\",\n    dataIndex: \"\",\n    key: \"actions\",\n    render: (text: string, record: Person) => (\n      <PeopleTableDeleteButton person={record} />\n    )\n  }\n];\n","import React, { useContext } from \"react\";\nimport classNames from \"classnames\";\nimport { Table } from \"antd\";\n\nimport { PeopleTableColumns } from \"./PeopleTableColumns\";\nimport { PeopleContext } from \"../../contexts/PeopleContext\";\nimport \"./PeopleTable.scss\";\n\ninterface PeopleTableProps {\n  className?: String;\n}\n\nconst PeopleTable: React.FC<PeopleTableProps> = ({ className }) => {\n  const peopleContext = useContext(PeopleContext);\n  const data = peopleContext.people.map(person => ({\n    ...person,\n    key: person.id\n  }));\n  return (\n    <div className={classNames(className, \"people-table-container\")}>\n      <Table\n        dataSource={data}\n        columns={PeopleTableColumns(peopleContext)}\n        size=\"middle\"\n        pagination={{ pageSize: 30 }}\n      />\n    </div>\n  );\n};\n\nexport default PeopleTable;\n","import React, { useRef } from \"react\";\nimport { PlusOutlined } from \"@ant-design/icons\";\n\nimport \"./AddButton.scss\";\n\ninterface AddButtonProps {\n  onClick: () => void;\n}\n\nconst AddButton: React.FC<AddButtonProps> = ({ onClick }) => {\n  const buttonRef = useRef<HTMLButtonElement>(null);\n\n  const handleButton = () => {\n    /**\n     * We want to un focus the button once it was clicked in order\n     * to prevent accidental clicks when we press Enter for example.\n     */\n    if (buttonRef && buttonRef.current) {\n      buttonRef.current.blur();\n    }\n    onClick();\n  };\n\n  return (\n    /**\n     * This is a plain button and not Antd's Button because\n     * we need a way to blur the button once clicked.\n     */\n    <button\n      ref={buttonRef}\n      onClick={handleButton}\n      type=\"button\"\n      className=\"ant-btn add-button ant-btn-primary ant-btn-circle ant-btn-lg\"\n    >\n      <PlusOutlined />\n    </button>\n  );\n};\n\nexport default AddButton;\n","import React, { useState, useContext, KeyboardEvent } from \"react\";\nimport AddButton from \"../actions/AddButton\";\nimport {\n  Modal,\n  Form,\n  Input,\n  Radio,\n  Checkbox,\n  message,\n  AutoComplete\n} from \"antd\";\nimport {\n  PERSON_STATUSES,\n  AVAILABILITY,\n  PERSON_PREFERENCES,\n  SUBJECTS,\n  MEGAMUT,\n  MEGAMUT_TO_COLOR,\n  PREFERENCE_TO_COLOR\n} from \"../../consts\";\nimport TextArea from \"antd/lib/input/TextArea\";\nimport TagList from \"../tags/TagList\";\nimport { PeopleContext } from \"../../contexts/PeopleContext\";\nimport {\n  GET_PERSONAL_ID_RULES,\n  GET_BASIC_TEXT_RULES,\n  GET_PHONE_NUMBER_RULES\n} from \"../validators/validators\";\n\nconst layout = {\n  labelCol: { span: 5 },\n  wrapperCol: { span: 19 }\n};\n\nconst initialValues = {\n  fullName: \"\",\n  personId: \"\",\n  phone: \"\",\n  status: PERSON_STATUSES[0],\n  team: \"\",\n  preferences: [],\n  megamut: [],\n  subjects: [],\n  availability: AVAILABILITY[0],\n  wasSegel: false,\n  remarks: \"\"\n};\n\nconst AddPersonModal: React.FC = () => {\n  const [visible, setVisible] = useState(false);\n  const [form] = Form.useForm();\n  const { addPerson, doesPersonExist, getFieldDataSet } = useContext(\n    PeopleContext\n  );\n  const possibleTeams = getFieldDataSet(\"team\");\n\n  const showModal = () => {\n    setVisible(true);\n  };\n\n  const hideModal = () => {\n    setVisible(false);\n  };\n\n  const handleEnter = (event: KeyboardEvent<HTMLFormElement>) => {\n    if (event.key === \"Enter\") {\n      submitModal();\n    }\n  };\n\n  const submitModal = () => {\n    form\n      .validateFields()\n      .then(values => {\n        form.resetFields();\n        addPerson(values as any);\n        hideModal();\n        message.success(`${values.fullName} נוצר בהצלחה`);\n      })\n      .catch(() => {});\n  };\n\n  return (\n    <>\n      <AddButton onClick={showModal} />\n      <Modal\n        onOk={submitModal}\n        title=\"הוספת איש חוץ\"\n        visible={visible}\n        onCancel={hideModal}\n        okText=\"הוספה\"\n        cancelText=\"ביטול\"\n      >\n        <Form\n          {...layout}\n          size=\"small\"\n          form={form}\n          name=\"add_person_form\"\n          initialValues={initialValues}\n          onKeyDown={handleEnter}\n        >\n          <Form.Item\n            name=\"fullName\"\n            label=\"שם מלא\"\n            rules={GET_BASIC_TEXT_RULES()}\n          >\n            <Input />\n          </Form.Item>\n          <Form.Item\n            name=\"personalId\"\n            label=\"מ.א\"\n            rules={GET_PERSONAL_ID_RULES(doesPersonExist)}\n          >\n            <Input />\n          </Form.Item>\n          <Form.Item\n            name=\"phone\"\n            label=\"פלאפון\"\n            rules={GET_PHONE_NUMBER_RULES()}\n          >\n            <Input />\n          </Form.Item>\n          <Form.Item name=\"team\" label=\"צוות\">\n            <AutoComplete\n              onKeyDown={event => {\n                event.stopPropagation();\n              }}\n              options={possibleTeams.map(team => ({ value: team }))}\n            />\n          </Form.Item>\n          <Form.Item name=\"status\" label=\"מצב שירות\">\n            <Radio.Group>\n              {PERSON_STATUSES.map(status => (\n                <Radio key={status} value={status}>\n                  {status}\n                </Radio>\n              ))}\n            </Radio.Group>\n          </Form.Item>\n          <Form.Item name=\"availability\" label=\"זמינות\">\n            <Radio.Group>\n              {AVAILABILITY.map(availability => (\n                <Radio key={availability} value={availability}>\n                  {availability}\n                </Radio>\n              ))}\n            </Radio.Group>\n          </Form.Item>\n          <Form.Item name=\"wasSegel\" label=\"סגל עבר\" valuePropName=\"checked\">\n            <Checkbox />\n          </Form.Item>\n          <Form.Item name=\"preferences\" label=\"העדפות\" valuePropName=\"tags\">\n            <TagList\n              possibleTags={PERSON_PREFERENCES}\n              colors={PREFERENCE_TO_COLOR}\n              additionText=\"הוספת העדפה\"\n            />\n          </Form.Item>\n          <Form.Item name=\"megamut\" label=\"מגמות\" valuePropName=\"tags\">\n            <TagList\n              possibleTags={MEGAMUT}\n              colors={MEGAMUT_TO_COLOR}\n              additionText=\"הוספת מגמה\"\n            />\n          </Form.Item>\n          <Form.Item name=\"subjects\" label=\"מערכים\" valuePropName=\"tags\">\n            <TagList possibleTags={SUBJECTS} additionText=\"הוספת מערך\" />\n          </Form.Item>\n          <Form.Item name=\"remarks\" label=\"הערות נוספות\">\n            <TextArea />\n          </Form.Item>\n        </Form>\n      </Modal>\n    </>\n  );\n};\n\nexport default AddPersonModal;\n","import React from \"react\";\nimport { Layout, Menu } from \"antd\";\nimport { PeopleContextProvider } from \"./contexts/PeopleContext\";\nimport PeopleTable from \"./components/PeopleTable/PeopleTable\";\n\nimport \"antd/dist/antd.css\";\nimport \"./rtl.scss\";\nimport \"./App.scss\";\nimport AddPersonModal from \"./components/PeopleTable/AddPersonModal\";\n\nconst { Header, Content, Footer } = Layout;\n\nconst App: React.FC = () => {\n  return (\n    <Layout className=\"layout\">\n      <Header>\n        <div className=\"logo\" />\n        <Menu theme=\"dark\" mode=\"horizontal\" style={{ lineHeight: \"64px\" }}>\n          <Menu.Item> מנהל אנשי חוץ </Menu.Item>\n        </Menu>\n      </Header>\n      <Content>\n        <PeopleContextProvider>\n          <PeopleTable className=\"people-manager-table\" />\n          <AddPersonModal />\n        </PeopleContextProvider>\n      </Content>\n      <Footer>Bis Hibur ©2019 Created by Nir Geller</Footer>\n    </Layout>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}